# -*- coding: utf-8 -*-
"""max_distance_closePacking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U6VVNuuQ35YzSxB5-TuWwk57s55zzGts
"""

import numpy as np

class Vector3D:
    def __init__(self, v):
        self.v = np.array(v)

    def magnitude(self):
        return np.linalg.norm(self.v)

def rotate_vector(axis, theta, vector):
    axis = np.array(axis)
    axis = axis / np.linalg.norm(axis)
    cos_theta = np.cos(theta)
    sin_theta = np.sin(theta)
    # Matriz de rotación usando la fórmula de Rodrigues
    rotation_matrix = np.array([
        [cos_theta + axis[0]**2 * (1 - cos_theta), axis[0] * axis[1] * (1 - cos_theta) - axis[2] * sin_theta, axis[0] * axis[2] * (1 - cos_theta) + axis[1] * sin_theta],
        [axis[1] * axis[0] * (1 - cos_theta) + axis[2] * sin_theta, cos_theta + axis[1]**2 * (1 - cos_theta), axis[1] * axis[2] * (1 - cos_theta) - axis[0] * sin_theta],
        [axis[2] * axis[0] * (1 - cos_theta) - axis[1] * sin_theta, axis[2] * axis[1] * (1 - cos_theta) + axis[0] * sin_theta, cos_theta + axis[2]**2 * (1 - cos_theta)]
    ])
    return np.dot(rotation_matrix, vector.v)

import numpy as np

class Molecule:
    def __init__(self, coordinates, symbols, radii):
        self.coordinates = np.array(coordinates)  # Array of vectors
        self.symbols = np.array(symbols)
        self.radii = np.array(radii)  # Array of van der Waals radii for each atom type

def calculate_contact(molecule, direction_vector):
    n_atoms = len(molecule.coordinates)
    max_displacement = 0
    for i in range(n_atoms):
        for j in range(n_atoms):
            if i != j:
                distance_vector = molecule.coordinates[i] - molecule.coordinates[j]
                distance = np.linalg.norm(distance_vector)
                projection = np.dot(distance_vector, direction_vector) / np.linalg.norm(direction_vector)
                normal_distance = np.sqrt(distance**2 - projection**2)
                sum_vdw = molecule.radii[molecule.symbols[i]] + molecule.radii[molecule.symbols[j]]
                if normal_distance <= sum_vdw:
                    displacement = projection + np.sqrt(abs(sum_vdw**2 - normal_distance**2))
                    if displacement > max_displacement:
                        max_displacement = displacement
    return max_displacement

def find_max_projection(molecule, directions):
    max_projections = [calculate_contact(molecule, dir) for dir in directions]
    max_index = np.argmax(max_projections)
    return max_projections[max_index], directions[max_index]

def minimize_cell_parameters(molecule, directions, initial_parameters):
    optimized_parameters = initial_parameters
    for angle in np.linspace(0, 2 * np.pi, 360):
        rotated_molecule = rotate_molecule(molecule, angle)
        max_projection, _ = find_max_projection(rotated_molecule, directions)
        if max_projection < optimized_parameters['min_distance']:
            optimized_parameters['min_distance'] = max_projection
            optimized_parameters['optimal_angle'] = angle
    return optimized_parameters

def rotate_molecule(molecule, angle):
    rotation_matrix = np.array([
        [np.cos(angle), -np.sin(angle), 0],
        [np.sin(angle), np.cos(angle), 0],
        [0, 0, 1]
    ])
    new_coordinates = np.dot(molecule.coordinates, rotation_matrix.T)
    return Molecule(new_coordinates, molecule.symbols, molecule.radii)

import numpy as np

class Molecule:
    def __init__(self, coordinates, symbols, atom_radii):
        self.coordinates = np.array(coordinates)  # Array of vectors
        self.symbols = symbols
        self.atom_radii = atom_radii  # Diccionario de radios atómicos

    def get_radius(self, atom_index):
        atom_type = self.symbols[atom_index]
        return self.atom_radii.get(atom_type, 1.5)  # Valor por defecto si no se encuentra

def read_sdf(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    molecule_data = []
    reading_molecule = False

    for line in lines:
        if line.startswith('$$$$'):
            reading_molecule = False
        if reading_molecule:
            parts = line.split()
            if len(parts) >= 4:
                try:
                    # Convertir coordenadas a float y determinar el tipo de átomo
                    x, y, z = float(parts[0]), float(parts[1]), float(parts[2])
                    atom_type = parts[3]
                    molecule_data.append((x, y, z, atom_type))
                except ValueError:
                    continue
        if line.strip().endswith('V2000'):
            reading_molecule = True
            molecule_data = []  # Reiniciar para cada nueva molécula

    # Asignar un radio de van der Waals a cada tipo de átomo (esto es un ejemplo)
    atom_radii = {
        'C': 1.7, 'H': 1.2, 'O': 1.52, 'N': 1.55, 'S': 1.8
    }
    coordinates = []
    symbols = []
    radii = []
    for (x, y, z, atom_type) in molecule_data:
        coordinates.append([x, y, z])
        symbols.append(atom_type)
        radii.append(atom_radii.get(atom_type, 1.5))  # Valor por defecto si no se encuentra

    return coordinates, symbols, radii

def calculate_contact(molecule, direction_vector):
    n_atoms = len(molecule.coordinates)
    max_displacement = 0
    for i in range(n_atoms):
        for j in range(i + 1, n_atoms):  # Asegura que no se compara un átomo consigo mismo y evita duplicados
            distance_vector = molecule.coordinates[i] - molecule.coordinates[j]
            distance = np.linalg.norm(distance_vector)
            projection = np.dot(distance_vector, direction_vector) / np.linalg.norm(direction_vector)
            normal_distance = np.sqrt(distance**2 - projection**2)
            sum_vdw = molecule.get_radius(i) + molecule.get_radius(j)
            if normal_distance <= sum_vdw:
                displacement = projection + np.sqrt(max(sum_vdw**2 - normal_distance**2, 0))
                if displacement > max_displacement:
                    max_displacement = displacement
    return max_displacement


#coordinates, symbols, radii = read_sdf('/content/PCBM-3D-structure-CT1089645246.sdf')
atom_radii = {
    'C': 1.7, 'H': 1.2, 'O': 1.52, 'N': 1.55, 'S': 1.8
}

molecule = Molecule(coordinates, symbols, atom_radii)
direction_vector = np.array([1, 0, 0])  # Ejemplo de dirección
max_displacement = calculate_contact(molecule, direction_vector)
#print("Máximo desplazamiento:", max_displacement)

import numpy as np
import plotly.graph_objects as go

class Molecule:
    def __init__(self, coordinates, symbols, atom_radii):
        self.coordinates = np.array(coordinates)  # Array of vectors
        self.symbols = symbols
        self.atom_radii = atom_radii  # Diccionario de radios atómicos

def read_sdf(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    coordinates = []
    symbols = []
    reading_molecule = False

    for line in lines:
        if line.strip().endswith('V2000'):
            reading_molecule = True
            continue
        if line.startswith('M  END') or line.startswith('$$$$'):
            reading_molecule = False
            continue

        if reading_molecule:
            parts = line.split()
            if len(parts) > 3 and parts[3].isalpha():
                try:
                    x, y, z = float(parts[0]), float(parts[1]), float(parts[2])
                    atom_type = parts[3]
                    coordinates.append([x, y, z])
                    symbols.append(atom_type)
                except ValueError:
                    continue

    # Configurar aquí los radios atómicos conocidos
    atom_radii = {
        'C': 1.7, 'H': 1.2, 'O': 1.52, 'N': 1.55, 'S': 1.8
    }
    return coordinates, symbols, atom_radii

def plot_molecule(coordinates, symbols, atom_radii):
    fig = go.Figure()

    atom_color = {
        'C': 'green', 'H': 'white', 'O': 'red', 'N': 'blue', 'S': 'yellow'
    }
    displacement_vector = max_displacement*direction_vector/np.linalg.norm(direction_vector)
    print(displacement_vector)

    for coord, symbol in zip(coordinates, symbols):
        radius = atom_radii.get(symbol, 1.0)  # Uso de get para evitar KeyError, con 1.0 como valor por defecto
        theta, phi = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
        for addition in [0, 1]:
            disp = displacement_vector * addition
            x = coord[0] + disp[0] + radius * np.sin(phi) * np.cos(theta)
            y = coord[1] + disp[1] + radius * np.sin(phi) * np.sin(theta)
            z = coord[2] + disp[2] + radius * np.cos(phi)

            color = atom_color.get(symbol, 'grey')  # Manejo de colores para tipos desconocidos
            fig.add_trace(go.Surface(x=x, y=y, z=z, colorscale=[[0, color], [1, color]], showscale=False))

    fig.update_layout(title='Visualización Molecular 3D con Imagen Desplazada',
                      autosize=False, width=800, height=800, margin=dict(l=0, r=0, b=0, t=0))
    fig.show()

# 
#coordinates, symbols, atom_radii = read_sdf('/content/PCBM-3D-structure-CT1089645246.sdf')
#plot_molecule(coordinates, symbols, atom_radii)

